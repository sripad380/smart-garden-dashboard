<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Smart Garden Dashboard</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
/* ---------- Global ---------- */
body {
  font-family: Arial, sans-serif;
  background: #eef2f3;
  padding: 20px;
  margin: 0;
}
h2, h3 {
  margin-top: 0;
}
.card {
  background: #ffffff;
  padding: 15px;
  margin-bottom: 20px;
  border-radius: 10px;
  box-shadow: 0 2px 5px #0002;
}
.cards-row {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}
.card-half {
  flex: 1 1 320px;
}

/* ---------- Connect button ---------- */
#connectBtn {
  padding: 10px 16px;
  margin: 10px 0 20px;
  background: #4CAF50;
  border: none;
  color: white;
  border-radius: 6px;
  font-size: 16px;
  cursor: pointer;
}

/* ---------- iOS-style toggle ---------- */
.toggle-wrapper {
  display: flex;
  align-items: center;
  gap: 8px;
  margin: 6px 0 12px;
}
.toggle-label-text {
  font-weight: bold;
  min-width: 140px;
}
.toggle {
  position: relative;
  width: 50px;
  height: 28px;
}
.toggle input {
  opacity: 0;
  width: 0;
  height: 0;
}
.toggle-slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  border-radius: 34px;
  transition: 0.3s;
}
.toggle-slider::before {
  position: absolute;
  content: "";
  height: 22px;
  width: 22px;
  left: 3px;
  bottom: 3px;
  background-color: #fff;
  border-radius: 50%;
  transition: 0.3s;
  box-shadow: 0 1px 3px #0004;
}
.toggle input:checked + .toggle-slider {
  background-color: #4CAF50;
}
.toggle input:checked + .toggle-slider::before {
  transform: translateX(22px);
}

/* ---------- Environment visuals ---------- */
.thermo {
  width: 60px;
  height: 200px;
  background: #ddd;
  border-radius: 30px;
  position: relative;
  margin: 10px auto;
  overflow: hidden;
}
.thermo-fill {
  position: absolute;
  bottom: 0;
  width: 100%;
  background: #ff4d4d;
  transition: height 0.3s;
}

.humidity-icon {
  width: 80px;
  height: 110px;
  margin: 20px auto;
  position: relative;
}
.humidity-drop {
  width: 80px;
  height: 110px;
  background: #b3e5fc;
  border-radius: 50% 50% 60% 60%;
  position: relative;
  overflow: hidden;
  box-shadow: 0 0 10px #90caf9 inset;
}
.humidity-fill {
  position: absolute;
  bottom: 0;
  width: 100%;
  height: 0%;
  background: #0288d1;
  transition: height 0.3s;
}

.soil-box {
  width: 120px;
  height: 120px;
  border: 3px solid #5d4037;
  border-radius: 10px;
  margin: 20px auto;
  position: relative;
  overflow: hidden;
  background: #f3e5ab;
}
.soil-water {
  position: absolute;
  bottom: 0;
  width: 100%;
  height: 0%;
  background: rgba(33, 150, 243, 0.6);
  transition: height 0.4s ease;
}

.sun-meter-box {
  width: 220px;
  height: 30px;
  background: #fff8e1;
  border-radius: 20px;
  margin: 20px auto;
  position: relative;
  overflow: hidden;
  border: 2px solid #ffca28;
}
.sun-meter-fill {
  position: absolute;
  left: 0;
  top: 0;
  height: 100%;
  width: 0%;
  background: linear-gradient(to right,
    #fff59d,
    #ffe082,
    #ffca28,
    #ffb300
  );
  transition: width 0.4s ease;
}

/* ---------- Speedometer ---------- */
.speedometer-container {
  width: 260px;
  height: 140px;
  margin: 15px auto 5px;
  position: relative;
}
.speedometer-arc {
  width: 100%;
  height: 100%;
  border-radius: 260px 260px 0 0;
  background: conic-gradient(
    from 180deg,
    #f44336,
    #ff9800,
    #ffeb3b
  );
  mask: radial-gradient(circle at 50% 100%, transparent 58%, black 59%);
}
.speedometer-inner {
  position: absolute;
  left: 15px;
  right: 15px;
  top: 15px;
  bottom: 0;
  border-radius: 260px 260px 0 0;
  background: #222;
  mask: radial-gradient(circle at 50% 100%, transparent 58%, black 59%);
}
.speedometer-ticks div {
  position: absolute;
  width: 2px;
  height: 12px;
  background: #eee;
  left: 50%;
  top: 18px;
  transform-origin: center 90px;
}
.speedometer-needle {
  position: absolute;
  left: 50%;
  bottom: 0;
  width: 4px;
  height: 80px;
  background: #ffeb3b;
  transform-origin: center bottom;
  transform: rotate(-90deg);
  transition: transform 0.15s linear;
}
.speedometer-knob {
  position: absolute;
  left: 50%;
  bottom: 0;
  width: 26px;
  height: 26px;
  border-radius: 50%;
  background: #f5f5f5;
  border: 3px solid #ffeb3b;
  transform: translateX(-50%) translateY(12px);
  cursor: grab;
}
.speedometer-value {
  text-align: center;
  margin-top: 4px;
  font-weight: bold;
}

/* ---------- Vertical LED slider ---------- */
.vertical-slider-box {
  width: 40px;
  height: 180px;
  background: #e0e0e0;
  border-radius: 20px;
  position: relative;
  overflow: hidden;
}
.vertical-slider-fill {
  position: absolute;
  bottom: 0;
  width: 100%;
  height: 0%;
  background: linear-gradient(to top, #ffcc80, #ff9800);
  transition: height 0.2s;
}
.vertical-slider-thumb {
  position: absolute;
  left: 50%;
  width: 34px;
  height: 10px;
  background: #ffffff;
  border-radius: 6px;
  transform: translateX(-50%) translateY(50%);
  cursor: grab;
}

/* ---------- Mobile Responsive ---------- */
@media (max-width: 768px) {
  body { padding: 10px; }
  .cards-row { flex-direction: column; }
  .speedometer-container { width: 200px; height: 110px; }
  .vertical-slider-box { height: 150px; }
}
</style>
</head>

<body>

<h2>ðŸŒ± Smart Garden BLE Dashboard</h2>
<button id="connectBtn">Connect to SmartGardenESP32</button>
<span id="deviceName" style="margin-left:12px; font-weight:bold;"></span>

<!-- ENVIRONMENT CARD -->
<div class="card">
  <h3>Environment</h3>
  <div style="display:flex; justify-content:space-around; flex-wrap:wrap;">

    <!-- Temperature -->
    <div style="text-align:center;">
      <h4>Temperature</h4>
      <div class="thermo"><div class="thermo-fill" id="thermoFill"></div></div>
      <p><b><span id="temp">--</span> Â°C</b></p>
    </div>

    <!-- Humidity -->
    <div style="text-align:center;">
      <h4>Humidity</h4>
      <div class="humidity-icon">
        <div class="humidity-drop">
          <div class="humidity-fill" id="humidityFill"></div>
        </div>
      </div>
      <p><b><span id="hum">--</span>%</b></p>
    </div>

    <!-- Soil -->
    <div style="text-align:center;">
      <h4>Soil Moisture</h4>
      <div class="soil-box">
        <div class="soil-water" id="soilWater"></div>
      </div>
      <p><b><span id="soilPercent">--</span>%</b></p>
    </div>

    <!-- Light -->
    <div style="text-align:center;">
      <h4>Light Level</h4>
      <div class="sun-meter-box">
        <div class="sun-meter-fill" id="lightMeter"></div>
      </div>
      <p><b><span id="lightPercent">--</span>%</b></p>
    </div>

  </div>
</div>

<div class="cards-row">

  <!-- PUMP CONTROL -->
  <div class="card card-half">
    <h3>Pump Control</h3>

    <div class="toggle-wrapper">
      <div class="toggle-label-text">Pump Power</div>
      <label class="toggle">
        <input type="checkbox" id="pumpToggle">
        <span class="toggle-slider"></span>
      </label>
    </div>

    <div class="speedometer-container" id="speedometer">
      <div class="speedometer-arc"></div>
      <div class="speedometer-inner"></div>
      <div class="speedometer-ticks" id="speedometerTicks"></div>
      <div class="speedometer-needle" id="speedometerNeedle"></div>
      <div class="speedometer-knob" id="speedometerKnob" tabindex="0" role="slider" aria-valuemin="0" aria-valuemax="255"></div>
    </div>

    <div class="speedometer-value">
      Pump Speed: <span id="pumpSpeedVal">0</span>
    </div>
  </div>

  <!-- LED CONTROL -->
  <div class="card card-half">
    <h3>LED Grow Light</h3>

    <div class="toggle-wrapper">
      <div class="toggle-label-text">LED Power</div>
      <label class="toggle">
        <input type="checkbox" id="ledToggle">
        <span class="toggle-slider"></span>
      </label>
    </div>

    <div class="vertical-slider-box" id="ledSliderBox">
      <div class="vertical-slider-fill" id="ledSliderFill"></div>
      <div class="vertical-slider-thumb" id="ledSliderThumb" tabindex="0" role="slider" aria-valuemin="0" aria-valuemax="255"></div>
    </div>

    <div style="text-align:center;">
      Brightness: <b><span id="ledVal">0</span></b>
    </div>
  </div>

</div>

<!-- MANUAL OVERRIDE -->
<div class="card">
  <h3>Manual Override</h3>
  <div class="toggle-wrapper">
    <div class="toggle-label-text">Override</div>
    <label class="toggle">
      <input type="checkbox" id="overdriveToggle">
      <span class="toggle-slider"></span>
    </label>
  </div>
</div>

<!-- THRESHOLDS -->
<div class="card">
  <h3>Automation Thresholds</h3>

  <div class="threshold-row" style="margin-bottom:10px;">
    <span><b>Soil Dry Threshold:</b></span>
    <input type="number" id="soilThresh" style="width:80px; margin-left:8px;" />
    <button id="setSoilThreshBtn" style="margin-left:8px;">Set</button>
  </div>

  <div class="threshold-row">
    <span><b>Light Low Threshold:</b></span>
    <input type="number" id="lightThresh" style="width:80px; margin-left:8px;" />
    <button id="setLightThreshBtn" style="margin-left:8px;">Set</button>
  </div>

</div>

<script>
/* ---------- BLE UUIDs ---------- */
const SERVICE_UUID = "4e520001-3c8c-4824-8f7d-2b4421d8b63e";
const DATA_UUID    = "4e520002-3c8c-4824-8f7d-2b4421d8b63e";
const CMD_UUID     = "4e520003-3c8c-4824-8f7d-2b4421d8b63e";

let device = null;
let server = null;
let service = null;
let dataChar = null;
let cmdChar = null;

/* ---------- Notification buffer for chunked payloads ---------- */
let notifyBuffer = "";

/* ---------- UI Elements ---------- */
const connectBtn = document.getElementById("connectBtn");
const deviceNameLabel = document.getElementById("deviceName");

const needle = document.getElementById("speedometerNeedle");
const knob = document.getElementById("speedometerKnob");
const speedDisplay = document.getElementById("pumpSpeedVal");
const pumpToggle = document.getElementById("pumpToggle");

const ledSliderBox = document.getElementById("ledSliderBox");
const ledFill = document.getElementById("ledSliderFill");
const ledThumb = document.getElementById("ledSliderThumb");
const ledValLabel = document.getElementById("ledVal");
const ledToggle = document.getElementById("ledToggle");

const overdriveToggle = document.getElementById("overdriveToggle");

let isDraggingNeedle = false;
let currentPumpSpeed = 0;

let isDraggingLED = false;
let currentLEDVal = 0;

/* ---------- Helpers ---------- */
function clamp(v, min, max) {
  return Math.min(max, Math.max(min, v));
}
function logBLE(msg) {
  console.log("[BLE] " + msg);
}
function isWebBluetoothSupported() {
  return !!(navigator && navigator.bluetooth);
}

window.writeQueue = window.writeQueue || [];
window.writeInProgress = window.writeInProgress || false;

const writeQueue = window.writeQueue;
let writeInProgress = window.writeInProgress;

async function doWrite(characteristic, data, tryCount = 0) {
  // choose method
  if (!characteristic) throw new Error("Characteristic not available");
  try {
    if (characteristic.properties.writeWithoutResponse && typeof characteristic.writeValueWithoutResponse === 'function') {
      // Some implementations return a Promise â€” await if so
      const p = characteristic.writeValueWithoutResponse(data);
      if (p && typeof p.then === 'function') await p;
    } else if (characteristic.properties.write && typeof characteristic.writeValue === 'function') {
      await characteristic.writeValue(data);
    } else {
      throw new Error("Characteristic not writable");
    }
    return;
  } catch (err) {
    // handle transient GATT-in-progress by retrying
    const msg = (err && err.message) ? err.message : String(err);
    if ((/GATT operation already in progress/i.test(msg) || /operation failed/i.test(msg)) && tryCount < 4) {
      // exponential backoff
      const delayMs = 50 + Math.pow(2, tryCount) * 30;
      await new Promise(r => setTimeout(r, delayMs));
      return doWrite(characteristic, data, tryCount + 1);
    }
    throw err;
  }
}

async function processWriteQueue() {
  if (writeInProgress) return;
  writeInProgress = true;
  while (writeQueue.length > 0) {
    const item = writeQueue.shift();
    const { data, resolve, reject } = item;
    try {
      await doWrite(cmdChar, data); // cmdChar is your command characteristic
      resolve();
    } catch (err) {
      console.error("write failed:", err);
      reject(err);
    }
    // small delay between writes to avoid hammering peripheral
    await new Promise(r => setTimeout(r, 60));
  }
  writeInProgress = false;
}

function enqueueWrite(cmd) {
  return new Promise((resolve, reject) => {
    try {
      const data = new TextEncoder().encode(cmd);
      writeQueue.push({ data, resolve, reject });
      processWriteQueue();
    } catch (e) {
      reject(e);
    }
  });
}

/* ---------- Connect ---------- */
connectBtn.addEventListener("click", async () => {
  if (!isWebBluetoothSupported()) {
    alert("Web Bluetooth API is not available in this browser. Use Chrome or Edge on a supported platform.");
    return;
  }

  connectBtn.disabled = true;
  connectBtn.textContent = "Connecting...";

  try {
    // Prefer service filter; also accept namePrefix for convenience.
    device = await navigator.bluetooth.requestDevice({
      filters: [{ name: "SmartGardenESP32" }],
      optionalServices: [SERVICE_UUID]
    });

    if (!device) {
      throw new Error("No device selected");
    }

    device.addEventListener('gattserverdisconnected', onDisconnected);

    server = await device.gatt.connect();
    service = await server.getPrimaryService(SERVICE_UUID);

    // Get characteristics
    dataChar = await service.getCharacteristic(DATA_UUID);
    cmdChar  = await service.getCharacteristic(CMD_UUID);

    // Start notifications if supported
    if (dataChar.properties.notify || dataChar.properties.indicate) {
      try {
        await dataChar.startNotifications();
        dataChar.addEventListener("characteristicvaluechanged", handleNotify);
      } catch (e) {
        console.warn("startNotifications failed:", e);
      }
    } else {
      console.warn("Data characteristic has no notify/indicate property");
    }

    deviceNameLabel.textContent = device.name ? `(${device.name})` : '';
    connectBtn.textContent = "Connected";
    connectBtn.style.background = "#999";
    connectBtn.disabled = true;
    logBLE("Connected to device: " + (device.name || device.id));
  } catch (e) {
    console.error("Connection Failed:", e);
    alert("Connection failed: " + (e.message || e));
    connectBtn.disabled = false;
    connectBtn.textContent = "Connect to SmartGardenESP32";
  }
});

/* ---------- Disconnection / Reconnect ---------- */
function onDisconnected(evt) {
  logBLE("Device disconnected");
  alert("Device disconnected");
  connectBtn.disabled = false;
  connectBtn.textContent = "Connect to SmartGardenESP32";
  connectBtn.style.background = "";
  deviceNameLabel.textContent = "";

  // Optionally attempt automatic reconnect a few times
  tryReconnect(3, 1500).catch(() => {
    logBLE("Auto-reconnect attempts finished");
  });
}

async function tryReconnect(retries = 3, delayMs = 1500) {
  if (!device) return;
  for (let i = 0; i < retries; i++) {
    try {
      logBLE(`Reconnect attempt ${i+1}/${retries}`);
      server = await device.gatt.connect();
      service = await server.getPrimaryService(SERVICE_UUID);
      dataChar = await service.getCharacteristic(DATA_UUID);
      cmdChar  = await service.getCharacteristic(CMD_UUID);

      if (dataChar.properties.notify || dataChar.properties.indicate) {
        await dataChar.startNotifications();
        dataChar.addEventListener("characteristicvaluechanged", handleNotify);
      }

      connectBtn.disabled = true;
      connectBtn.textContent = "Connected";
      connectBtn.style.background = "#999";
      deviceNameLabel.textContent = device.name ? `(${device.name})` : '';
      alert("Reconnected to device");
      return;
    } catch (err) {
      console.warn("Reconnect failed:", err);
      await new Promise(r => setTimeout(r, delayMs));
    }
  }
  // If reconnect unsuccessful, leave UI disconnected
  connectBtn.disabled = false;
  connectBtn.textContent = "Connect to SmartGardenESP32";
  deviceNameLabel.textContent = "";
  throw new Error("Unable to reconnect");
}

/* ---------- Notification handler (robust for chunked payloads) ---------- */
function decodeValueToString(value) {
  // value is a DataView
  if (value && value.buffer) {
    const slice = value.buffer.slice(value.byteOffset, value.byteOffset + value.byteLength);
    return new TextDecoder().decode(slice);
  }
  return new TextDecoder().decode(value);
}

/**
 * Notification handler for BLE device.
 * Accumulates partial chunks of JSON received from notifications in notifyBuffer.
 * When a complete JSON line is received, parses it and updates the UI.
 * If the JSON is not newline-delimited (NDJSON), will attempt to parse the whole buffer as a single JSON object.
 * @param {Event} event - The event containing the JSON data received from the device.
 */
function handleNotify(event) {
  const raw = decodeValueToString(event.target.value);
  // Many devices stream JSON with newline-delimited records (NDJSON).
  // Accumulate partial chunks in notifyBuffer and parse complete lines.
  notifyBuffer += raw;
  let newlineIndex;
  while ((newlineIndex = notifyBuffer.indexOf("\n")) !== -1) {
    const line = notifyBuffer.slice(0, newlineIndex).trim();
    notifyBuffer = notifyBuffer.slice(newlineIndex + 1);
    if (!line) continue;
    try {
      const d = JSON.parse(line);
      updateUIFromData(d);
    } catch (err) {
      console.warn("Failed to parse JSON from notification line:", line, err);
      // If not NDJSON but a full JSON in one chunk, try parsing the whole buffer (fallback)
      try {
        const d = JSON.parse(notifyBuffer.trim());
        notifyBuffer = "";
        updateUIFromData(d);
      } catch (e2) {
        // ignore; wait for more data
      }
    }
  }

  // If there's no newline and the device sends whole JSON in a single chunk without newline,
  // try to parse it as a whole (best-effort). This handles devices that don't use NDJSON.
  if (notifyBuffer && notifyBuffer.indexOf("{") === 0 && notifyBuffer.indexOf("}") !== -1) {
    try {
      const possible = notifyBuffer.trim();
      const d = JSON.parse(possible);
      notifyBuffer = "";
      updateUIFromData(d);
    } catch (e) {
      // not yet complete JSON; wait for more chunks
    }
  }
}

/* ---------- UI update logic from parsed data ---------- */
function updateUIFromData(d) {
  // Temperature (d.T expected in degrees Celsius)
  if (typeof d.T === 'number') {
    document.getElementById("temp").innerText = d.T.toFixed(1);
    // Map temperature into 0-100% fill for visualization.
    // Example mapping: -10Â°C -> 0%, 50Â°C -> 100%
    const tPercent = clamp(Math.round(((d.T - (-10)) / (50 - (-10))) * 100), 0, 100);
    document.getElementById("thermoFill").style.height = tPercent + "%";
  }

  // Humidity (d.H expected 0-100)
  if (typeof d.H === 'number') {
    const h = clamp(d.H, 0, 100);
    document.getElementById("hum").innerText = h.toFixed(1);
    document.getElementById("humidityFill").style.height = h + "%";
  }

  // Soil (d.M expected raw ADC 0-4095)
  if (typeof d.M === 'number') {
    let soilPercent = (d.M / 4095) * 100;
    soilPercent = clamp(Math.round(soilPercent), 0, 100);
    document.getElementById("soilPercent").innerText = soilPercent.toFixed(0);
    document.getElementById("soilWater").style.height = soilPercent + "%";
  }

  // Light (d.L expected raw ADC 0-4095)
  if (typeof d.L === 'number') {
    let lightPercent = (d.L / 4095) * 100;
    lightPercent = clamp(Math.round(lightPercent), 0, 100);
    document.getElementById("lightPercent").innerText = lightPercent.toFixed(0);
    document.getElementById("lightMeter").style.width = lightPercent + "%";
  }

  // Pump speed (d.P expected 0-255)
  if (typeof d.P === 'number') {
    setPumpSpeedUI(d.P);
  }

  // LED brightness (d.S expected 0-255)
  if (typeof d.S === 'number') {
    setLEDSliderUI(d.S);
  }
}

/* ---------- sendCmd replaced with queued writer (uses enqueueWrite) ---------- */
async function sendCmd(cmd) {
  if (!cmdChar) {
    alert("Not connected!");
    return;
  }
  try {
    await enqueueWrite(cmd);
    logBLE("Sent (queued): " + cmd);
  } catch (err) {
    console.error("Failed to send command:", err);
    alert("Failed to send command: " + (err && err.message ? err.message : err));
    // If disconnected, try to reconnect in background
    if (device && (!device.gatt || !device.gatt.connected)) {
      tryReconnect().catch(() => {});
    }
  }
}

/* ---------- Pump Speedometer UI and interaction ---------- */
function speedToAngle(speed) {
  return -90 + (speed / 255) * 180;
}
function angleToSpeed(angle) {
  return Math.round(((angle + 90) / 180) * 255);
}

function setPumpSpeedUI(speed) {
  currentPumpSpeed = clamp(Math.round(speed), 0, 255);
  needle.style.transform = `rotate(${speedToAngle(currentPumpSpeed)}deg)`;
  speedDisplay.textContent = currentPumpSpeed;
  knob.setAttribute("aria-valuenow", currentPumpSpeed);
}

function sendPumpSpeed() {
  if (pumpToggle.checked) {
    sendCmd("SET_PUMP_SPEED:" + currentPumpSpeed);
  }
}

knob.addEventListener("pointerdown", e => {
  e.preventDefault();
  isDraggingNeedle = true;
  knob.setPointerCapture(e.pointerId);
});
window.addEventListener("pointermove", e => {
  if (!isDraggingNeedle) return;
  const rect = knob.parentElement.getBoundingClientRect();
  const cx = rect.left + rect.width / 2;
  const cy = rect.bottom;
  const x = e.clientX - cx;
  const y = e.clientY - cy;
  let angle = Math.atan2(x, -y) * (180 / Math.PI);
  angle = clamp(angle, -90, 90);
  setPumpSpeedUI(angleToSpeed(angle));
});
window.addEventListener("pointerup", e => {
  if (isDraggingNeedle) {
    isDraggingNeedle = false;
    try { knob.releasePointerCapture(e.pointerId); } catch {}
    sendPumpSpeed();
  }
});

pumpToggle.addEventListener("change", () => {
  if (pumpToggle.checked) {
    sendCmd("PUMP_ON");
    sendPumpSpeed();
  } else {
    sendCmd("PUMP_OFF");
  }
});

/* ---------- LED Slider UI and interaction (with debounce) ---------- */
function setLEDSliderUI(value) {
  currentLEDVal = clamp(Math.round(value), 0, 255);
  const pct = Math.round((currentLEDVal / 255) * 100);
  ledFill.style.height = pct + "%";
  // Position the thumb: bottom offset is pct%
  const boxHeight = ledSliderBox.clientHeight;
  const thumbHeight = ledThumb.clientHeight || 10;
  const bottomPx = (pct / 100) * (boxHeight - thumbHeight);
  ledThumb.style.bottom = bottomPx + "px";
  ledValLabel.textContent = currentLEDVal;
  ledThumb.setAttribute("aria-valuenow", currentLEDVal);
}

function sendLEDVal() {
  if (ledToggle.checked) {
    sendCmd("SET_LED_BRIGHTNESS:" + currentLEDVal);
  }
}

// Debounce sending while dragging so we don't queue too many writes
let ledSendDebounceTimer = null;
function scheduleSendLED(debounceMs = 120) {
  clearTimeout(ledSendDebounceTimer);
  ledSendDebounceTimer = setTimeout(() => {
    sendLEDVal();
  }, debounceMs);
}

ledThumb.addEventListener("pointerdown", e => {
  e.preventDefault();
  isDraggingLED = true;
  ledThumb.setPointerCapture(e.pointerId);
});
window.addEventListener("pointermove", e => {
  if (!isDraggingLED) return;
  const rect = ledSliderBox.getBoundingClientRect();
  // y position relative to top of box
  const y = clamp(e.clientY - rect.top, 0, rect.height);
  // invert to get bottom percentage
  const pct = clamp(Math.round((1 - (y / rect.height)) * 100), 0, 100);
  const val = Math.round((pct / 100) * 255);
  setLEDSliderUI(val);
  // schedule a debounced send while dragging
  scheduleSendLED(120);
});
window.addEventListener("pointerup", e => {
  if (isDraggingLED) {
    isDraggingLED = false;
    try { ledThumb.releasePointerCapture(e.pointerId); } catch {}
    // send final value immediately
    clearTimeout(ledSendDebounceTimer);
    sendLEDVal();
  }
});

// Support clicking on the slider box to set value
ledSliderBox.addEventListener("click", e => {
  const rect = ledSliderBox.getBoundingClientRect();
  const y = clamp(e.clientY - rect.top, 0, rect.height);
  const pct = clamp(Math.round((1 - (y / rect.height)) * 100), 0, 100);
  const val = Math.round((pct / 100) * 255);
  setLEDSliderUI(val);
  sendLEDVal();
});

ledToggle.addEventListener("change", () => {
  if (ledToggle.checked) {
    sendCmd("LED_ON");
    sendLEDVal();
  } else {
    sendCmd("LED_OFF");
  }
});

/* ---------- Manual overdrive ---------- */
overdriveToggle.addEventListener("change", () => {
  if (overdriveToggle.checked) {
    sendCmd("OVERRIDE_ON");
  } else {
    sendCmd("OVERRIDE_OFF");
  }
});

/* ---------- Thresholds ---------- */
document.getElementById("setSoilThreshBtn").addEventListener("click", () => {
  const v = Number(document.getElementById("soilThresh").value);
  if (!Number.isFinite(v)) return alert("Enter a valid number for soil threshold");
  // Send as percentage or raw? Use percentage for clarity
  sendCmd("SET_MOISTURE_THRESH:" + clamp(Math.round(v), 0, 100));
});

document.getElementById("setLightThreshBtn").addEventListener("click", () => {
  const v = Number(document.getElementById("lightThresh").value);
  if (!Number.isFinite(v)) return alert("Enter a valid number for light threshold");
  sendCmd("SET_LIGHT_THRESH:" + clamp(Math.round(v), 0, 100));
});

/* ---------- Initialization: generate speedometer ticks (visual) ---------- */
(function drawTicks() {
  const ticks = document.getElementById("speedometerTicks");
  if (!ticks) return;
  // create 9 ticks evenly spaced from -90 to +90
  for (let i = 0; i <= 8; i++) {
    const d = document.createElement("div");
    const angle = -90 + (i / 8) * 180;
    d.style.transform = `rotate(${angle}deg) translateY(-72px)`;
    ticks.appendChild(d);
  }
})();

/* ---------- Accessibility: keyboard control for knob and thumb ---------- */
knob.addEventListener("keydown", (e) => {
  if (e.key === "ArrowLeft" || e.key === "ArrowDown") {
    setPumpSpeedUI(currentPumpSpeed - 5);
    sendPumpSpeed();
    e.preventDefault();
  } else if (e.key === "ArrowRight" || e.key === "ArrowUp") {
    setPumpSpeedUI(currentPumpSpeed + 5);
    sendPumpSpeed();
    e.preventDefault();
  }
});

ledThumb.addEventListener("keydown", (e) => {
  if (e.key === "ArrowDown" || e.key === "ArrowLeft") {
    setLEDSliderUI(currentLEDVal - 5);
    // schedule or send immediately
    scheduleSendLED(80);
    e.preventDefault();
  } else if (e.key === "ArrowUp" || e.key === "ArrowRight") {
    setLEDSliderUI(currentLEDVal + 5);
    scheduleSendLED(80);
    e.preventDefault();
  }
});

/* ---------- Initial UI defaults ---------- */
setPumpSpeedUI(0);
setLEDSliderUI(0);

</script>
</body>
</html>
